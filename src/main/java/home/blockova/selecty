mozem mat sucasne spusteny registracny program aj zadavat blocky do DB, lebo sa iba registruju blocky z uloh ktore sa na zaciatku nacitali, po skonceni registrovania sa nanova nacitaju nove ulohy

SELECTY

1. spocita blocky podla dni a registratora
select DAYOFMONTH(L.datum) as den, month(P.datum) as mesiac, count(*) from blocky L 
    join blocky P on L.blocek_id=P.blocek_id where registrator='staskova' group by den, mesiac order by mesiac 

2. spocita blocky podla hodin a registratora
select hour(datum) as hodina, count(*) from blocky 
 where registrator='staskova' group by hodina order by hodina


1.) sumar posledneho dna
select  P.meno, count(*) as pocet from blocky B 
join predajne P on p.dkp=b.dkp 
where time_inserted > dateadd('day', -1, CURRENT_DATE) group by p.meno order by pocet desc

INSERT INTO register_log (BLOCEK_ID, LOGIN1, LOGIN2, LOGIN3, STATUS1, STATUS2, STATUS3) VALUES(2046306, '', '', '', 'TODO', 'TODO', 'TODO')
update register_log 
set status3='MAKRO' 
where blocek_id in (select b.blocek_id from blocky b join register_log r on b.BLOCEK_ID=r.BLOCEK_ID where b.POCET>0 and (r.status3='TODO' ))

select * from blocky

update blocky B set time_inserted=(select datum from blocky B2 where B2.blocek_id=B.blocek_id) where blocek_id<2016476

update blocky B set time_inserted=timestamp('2014-04-14 08:00:00') where blocek_id>2016476

select * from blocky order by blocek_id desc

select dkp, count(*) as pocet from blocky where time_inserted > dateadd('day', -1, CURRENT_DATE) group by dkp

-- spocita blocky od predajni
select B.dkp, P.meno, count(*) as pocet from blocky B 
join predajne P on p.dkp=b.dkp 
where time_inserted > dateadd('day', -1, CURRENT_DATE) group by b.dkp, p.meno

-- spocita za kazdy den v mesiaci kolko blockov bolo
select DAYOFMONTH(L.datum) as den, month(P.datum) as mesiac, count(*) from blocky L join blocky P on L.blocek_id=P.blocek_id group by den, mesiac order by mesiac 

select DAYOFMONTH(L.datum) as den, month(P.datum) as mesiac, count(*) from blocky L join blocky P on L.blocek_id=P.blocek_id 
    where dkp='7441020772654006' group by den, mesiac order by mesiac 

select count(*) as pocet from blocky where dkp in ('7002020023346010','700202002334609','7002020023346011') and time_inserted > dateadd('day', -1, CURRENT_DATE)

CREATE TABLE Loginy ( login_ID integer GENERATED BY DEFAULT AS IDENTITY (START WITH 1),meno varchar(255) NOT NULL, heslo varchar(255) NOT NULL, PRIMARY KEY (login_ID));

update blocky set datum=dateadd('day', -30, datum) where dayofmonth(datum)=28 and month(datum)=7
select * from blocky order by blocek_id desc

update blocky set time_makro_generated=CURRENT_DATE where time_makro_generated is null
select * from blocky b join register_log r on b.blocek_id=r.BLOCEK_ID






TODO
    - opravit bug nacitania blockov nie podla posledneho datumu registracie ale podla tych co este neboli registrovane- NOT RELEVANT, 
    - dokoncit riadnu verziu- OK
    - ochrana proti spekulantom 2000 blockov - OK
    - webstranku
    - zlavu za pizzu a kofolu blocek
    - facebook fanpage
    - vypnut sysout OK
















Autentifikacia
DEMO verzia
    - pri spustani budem overovat kolko je registracii na mojej macadrese - nepusti ma pridavat blocky ak bude viacej registracii ako je limit
    - pri pridavani blockov nepustim id viac ako limit - jeden demo nepusti viacej blockov, musi sa stahovat nove demo
bud to zlyha na vysokom id alebo na pocte registracii
najhorsie bude pocet registracii limit*3-1, vtedy stiahne nove demo a dovoli mu to zadat dalsich 50 blockov a ich zaregistrovat, ale viacej uz nie
- skript ktory prida noveho uzivatela s poctom, alebo zvysi jeho pocet registracii o cislo ak existuje v db

RIADNA VERZIA:
1. na idcko nie su ziadne mac adresy namapovane
        jednoducho sa insertne mac a idcko s poctom do db
2. na idcko su 1 macadresa namapovana
        - tato macadresa je aktualna macadresa
        - nova macadresa
3. na idcko su 2 macadresy namapovane
    - jedna z mac adries je moja
    - ani jedna z macadries nie je moja
IMPLEMENTACIA:
    - spravim osobitny formular na dotazovanie sa udajov pre appid, ktory mi vrati macadresy namapovane na dane id
zistim pocet roznych macadries pre appid: 
    select count(*) as pocet from (select * from customer where appid=700 group by name, appid) as T
vypisem macadresy: 
    select name, appid from customer where appid=70 group by name, appid
    1. ak je zoznam mensi ako 2, spravim jednoduchy insert ako v demo verzii
    2. ak je zoznam >1 a je tam moja macadresa, spravim jednoduchy insert
    3. ak je zoznam >1 a nie je tam moja macadresa, nepustim uzivatela dalej


    - bude sa pytat kolko roznych mac adries je zaregistrovanych na jeho id
    - ak jedna z tych macadries je jeho macadresa alebo je ich menej ako 2, tak 



select count(*) as pocet, `name` from customer where appid=70 group by name, appid


REGISTRACIA BLOCKOV
- v databaze tabulka s blocek_id a overovacie kody pre login1,login2,login3

1. zvolit ktore loginy pouzit pri registracii
2. vytvorit pole booleanov ktore vravia ktore loginy pouzivat
3. vytvorit pole 3 clientov a potom uz medzi nimi prepinat pri jednotlivych operaciach













